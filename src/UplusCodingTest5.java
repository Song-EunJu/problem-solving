//public class UplusCodingTest5 {
//    public static void main(String[] args) {4
//        // 탐욕 알고리즘
//        // : 말 그대로 선택의 순간마다 당장 눈앞에 보이는 최적의 상황만을 쫓아 최종적인 해답에 도달하는 방법
//        /*
//            어디에서든 사람수 >= 식인종 수
//            고려할 사항 : 배가 이동하려면 최소 1명 이상 탑승
//
//            아무도 죽지않고 안전하게 이동하기 위해 배를 이동시키는 최소횟수
//            -> 최소횟수가 나오려면..
//
//            1. a->b로 보내는 경우
//            - b로 보낼 수 있는 경우의 수를 모두 구함
//            - 하나씩 선택하면서, 배 / 남은 a의 인원 / 도착 시 b의 인원 체크
//
//         */
//
//    }
//}
//
//
////         * 1. b로 갈 배에 태울 때 사람수 >= 식인종수
////         *
////         *  b로 갈 배에 태운 후, a에 남은 사람수 >= 식인종 수라면 keep going
////         *                    a에 남은 사람수 < 식인종 수라면 return -1;
////         *
////         * 2. b에 도착했을 때 b에서의 사람수 >= 식인종 수라면 keep going
////         *                  b에서의 사람수 < 식인종 수라면 return -1;
////         *
////         * 3. a로 갈 배에 태울 때 사람 수 >= 식인종 수
////         *
////         * a로 갈 배에 태운 후, b에 남은 사람 수 >= 식인종 수라면 keep going
////         *                   b에 남은 사람수 < 식인종 수라면 return -1;
////         *
////         * 4. a에 도착했을 때, a에서의 사람수 >= 식인종 수라면 keep going
////         *                   a에서의 사람수 < 식인종 수라면 return -1;
////         *
////         * n m p result
////         * 2 2 2 5
////         * 2 2 1 -1
//
////        int n = 2;
////        int m = 2;
////        int p = 2;
////        int aPeople = 2;
////        int aZombie = 2;
////        int bPeople = 0;
////        int bZombie = 0;
////        // 처음에 사람2명 보내는 경우는 무조건 안됨!!
////
////        while (aPeople!=0 && aZombie!=0) { // a가 텅비기 전까지
////            if(bPeople==0 && bZombie==0){ // 완전 처음에는
////                // 처음에 사람 2명 보내는 경우 xxxxx
////
////                if(aPeople < p){ // 사람 수가 최대 인원보다 작은 경우
////                    for(int i=0;i<=aPeople;i++){
////                        aPeople -= i; // 사람이 안가는 만큼 좀비라도 가라
////                        aZombie -= (p-i);
////                        bPeople += i;
////                        bZombie += (p-i);
////                    }
////                }
////                else {
////
////                }
////
////                // 누가 타고 돌아올 것이냐
////                for(int i=0;i<bPeople;i++){
////
////                }
////                // b에서 a로 되돌아오기
////                if(bPeople == 0){
////                    // 되돌아올 때
////                    aZombie++;
////                    bZombie--;
////                    if(aPeople < aZombie || bPeople < bZombie)
////                        return -1; // 안전하게 이동불가
////
////                }
////
////            }
////        }
////
////
////        /* 백트래킹인가? -> 죽는 경우에 다시 되돌아와서 다른 애를
////        1) 사람2, 좀비2
////        -> 사람2명을 먼저 B로 보낸다
////        -> A로 무조건 사람1명은 와야함
////        -> 그러면 A에서 좀비2, 사람1로 사람 죽음
////
////        누군가를 보내고, 다시 A로 돌아올 때 1명을 누굴 선택하느냐 까지 고려해야 함
////
////
////        -> 사람 1명, 좀비 1명을 B로 보냄
////            -> 사람1명이 A에 돌아옴
////            -> 사람1, 좀비1 이 B로 가면 좀비2, 사람1로 사망
////
////            -> 사람1명이 A에 돌아옴
////            -> 사람2가 B로 감
////            -> B에는 사람2, 좀비1
////            -> 여기서 사람이 또 가버리면 무한루프
////            -> 좀비가 A에 갓다가 2명 좀비가 같이 돌아옴
////
////            -> 좀비1명이 A에 돌아옴
////            -> 사람1, 좀비 2로 A에서 사람 1 사망
////         */
////
////
////    }
