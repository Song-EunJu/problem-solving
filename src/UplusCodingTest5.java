public class UplusCodingTest5 {
    // 시작, 종료 , 중간 상태
    // 각 상태에서 어떤 상태로 반환할 수 있는지에 대한 정보

    public static void main(String[] args) {
        // 탐욕 알고리즘
        // : 말 그대로 선택의 순간마다 당장 눈앞에 보이는 최적의 상황만을 쫓아 최종적인 해답에 도달하는 방법
        /*
            어디에서든 사람수 >= 식인종 수
            고려할 사항 : 배가 이동하려면 최소 1명 이상 탑승

            아무도 죽지않고 안전하게 이동하기 위해 배를 이동시키는 최소횟수
            -> 최소횟수가 나오려면..

            1. a->b로 보내는 경우
            - b로 보낼 수 있는 경우의 수를 모두 구함 (여기서 배의 인원이 사람이 더 적은 경우는 쳐내고)
            - 하나씩 선택하면서, 배 / 남은 a의 인원 / 도착 시 b의 인원 체크

            -> 그리디라고 하더라도, 만약 사람 2명을 b로 보냈어. 그리고 그 중 한명을 배에 실어서 a로 다시 돌아오면
            -> 그 사람은 a섬에서 죽게됨. 만약 죽으면 다시 경우의 수를 체크해야 함. -> 백트래킹???
            사람 1명, 식인종 1명을 보내는 걸로 체크. ->
            식인종 2명 보내는 경우 ->

            2. b->a로 보내는 경우 (배를 태워 보내는 경우)
            - 배를 태울 수 있는 경우의 수를 모두 구함 (여기서 배의 인원이 사람이 더 적은 경우는 쳐내고)
            - 하나씩 선택하면서, 배 / 남은 a의 인원 / 도착 시 a의 인원 체크
            -> 식인종 1명이 오는 경우
            -> 사람1명, 식인종 1명을 보내는 경우 (처음상태로 고대로 돌아오게는 보내지 않도록 하자?)

            갈림길이 많을텐데 여기서 어떻게 min 값을 구하지
         */
        int aPeople = 2;
        int aZombie = 2;
        int bPeople = 0;
        int bZombie = 0;
        int allPeople = aPeople + aZombie; // 사람 + 좀비
        int shipMin = 2;


        // dfs1
        while (aPeople!=0 && aZombie!=0) { // a가 텅비기 전까지 반복문을 돈다
            // 1. a에서 b로 보내는 경우의 수
            for(int i=aPeople;i>=0;i--){
                // i: 보내는 사람
                // shipMin - i: 보내는 식인종

                // *** 최소 1명이면 최소를 선택할지, 최대를 선택할지 어떻게 정하지??
                if(i>=shipMin-i){
                    // a에 남게 되는 인원 체크
                    if(aPeople - i >= aZombie-(shipMin-i)) {
                        aPeople -= i;
                        aZombie -= (shipMin-i);
                    }
                    else continue;

                    // 보냈을 때 b에 있을 인원 체크
                    if(bPeople + i >= bZombie-(shipMin-i)){

                    }
                    else continue;
                } else
                    break;
            }
//            // 2. b에서 a로 보낼 (배에 태울) 경우의 수
//
//            if(bPeople==0 && bZombie==0){ // 완전 처음에는
//                // 처음에 사람 2명 보내는 경우 xxxxx
//
//                if(aPeople < p){ // 사람 수가 최대 인원보다 작은 경우
//                    for(int i=0;i<=aPeople;i++){
//                        aPeople -= i; // 사람이 안가는 만큼 좀비라도 가라
//                        aZombie -= (p-i);
//                        bPeople += i;
//                        bZombie += (p-i);
//                    }
//                }
//                else {
//
//                }
//
//                // 누가 타고 돌아올 것이냐
//                for(int i=0;i<bPeople;i++){
//
//                }
//                // b에서 a로 되돌아오기
//                if(bPeople == 0){
//                    // 되돌아올 때
//                    aZombie++;
//                    bZombie--;
//                    if(aPeople < aZombie || bPeople < bZombie)
//                        return -1; // 안전하게 이동불가
//
//                }
//
//            }
        }
    }
}

////         * 1. b로 갈 배에 태울 때 사람수 >= 식인종수
////         *
////         *  b로 갈 배에 태운 후, a에 남은 사람수 >= 식인종 수라면 keep going
////         *                    a에 남은 사람수 < 식인종 수라면 return -1;
////         *
////         * 2. b에 도착했을 때 b에서의 사람수 >= 식인종 수라면 keep going
////         *                  b에서의 사람수 < 식인종 수라면 return -1;
////         *
////         * 3. a로 갈 배에 태울 때 사람 수 >= 식인종 수
////         *
////         * a로 갈 배에 태운 후, b에 남은 사람 수 >= 식인종 수라면 keep going
////         *                   b에 남은 사람수 < 식인종 수라면 return -1;
////         *
////         * 4. a에 도착했을 때, a에서의 사람수 >= 식인종 수라면 keep going
////         *                   a에서의 사람수 < 식인종 수라면 return -1;
////         *
////         * n m p result
////         * 2 2 2 5
////         * 2 2 1 -1
//
////        int n = 2;
////        int m = 2;
////        int p = 2;
////        int aPeople = 2;
////        int aZombie = 2;
////        int bPeople = 0;
////        int bZombie = 0;
////        // 처음에 사람2명 보내는 경우는 무조건 안됨!!
////
////
////
////
////        /* 백트래킹인가? -> 죽는 경우에 다시 되돌아와서 다른 애를
////        1) 사람2, 좀비2
////        -> 사람2명을 먼저 B로 보낸다
////        -> A로 무조건 사람1명은 와야함
////        -> 그러면 A에서 좀비2, 사람1로 사람 죽음
////
////        누군가를 보내고, 다시 A로 돌아올 때 1명을 누굴 선택하느냐 까지 고려해야 함
////
////
////        -> 사람 1명, 좀비 1명을 B로 보냄
////            -> 사람1명이 A에 돌아옴
////            -> 사람1, 좀비1 이 B로 가면 좀비2, 사람1로 사망
////
////            -> 사람1명이 A에 돌아옴
////            -> 사람2가 B로 감
////            -> B에는 사람2, 좀비1
////            -> 여기서 사람이 또 가버리면 무한루프
////            -> 좀비가 A에 갓다가 2명 좀비가 같이 돌아옴
////
////            -> 좀비1명이 A에 돌아옴
////            -> 사람1, 좀비 2로 A에서 사람 1 사망
////         */
////
////
////    }
