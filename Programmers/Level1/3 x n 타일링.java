// n이 홀수인 경우에는 채울 수 없으니까 n 짝수인 경우만 고려!
// siang 이딴 거지같은 문제가... 사실 내가 이해를 못해서 거지같은 문제
/**
 * 1. f(2) 을 구성하는 것 : 3
 * 2. f(4) 을 구성하는 것
 *    - f(2) 짜리 두 세트 붙여서 만들기 = 3*3 = 9
 *    - f(2) 로 붙여서 만들 수 없는 변종 2개
 *    - f(4) = f(2) * f(2) + 2 = 11
 * 3. f(6) 을 구성하는 것
 *    - f(4) * f(2) = 11 * 3 = 33
 *    - f(2) * 2 (f(4)에서 만들어진 변종 2개) -> 나는 이생각을 못할 것 같다 ...
 *    - 2 (f(6) 에서도 생기는 변종 2개)
 * 4. f(8) 을 구성하는 것
 *    - f(6) * f(2)
 *    - f(4) * 2 (f(4)에서 만들어진 변종 2개)
 *    - f(2) * 2 (f(6)에서 만들어진 변종 2개)
 *    - 2 (f(8)에서도 생기는 변종 2개)
 * */
class Solution {
    public int solution(int n) {
        long mod = 1000000007;
        long dp[] = new long[n+1];

        if(n%2 == 1)
            return 0;

        dp[0] = 1;
        dp[2] = 3;

        for(int i=4;i<=n;i+=2){
            dp[i] += dp[i-2] * dp[2];
            for(int j=i-4;j>0;j-=2){
                dp[i] = (dp[j] * 2 + dp[i])%mod;
            }
            dp[i] += 2;
        }
        return (int)(dp[n]%mod);
    }
}